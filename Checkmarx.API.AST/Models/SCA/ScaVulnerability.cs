using System;
using System.Collections.Generic;
using System.Text.Json.Serialization; // For JsonPropertyName attribute

namespace Checkmarx.API.AST.Models.SCA
{
    /// <summary>
    /// Represents a single vulnerability item.
    /// </summary>
    public class ScaVulnerability
    {
        [JsonPropertyName("credit")]
        public string? Credit { get; set; }

        [JsonPropertyName("state")]
        public string? State { get; set; }

        [JsonPropertyName("isIgnored")]
        public bool IsIgnored { get; set; }

        [JsonPropertyName("cve")]
        public string? Cve { get; set; }

        [JsonPropertyName("cwe")]
        public string? Cwe { get; set; }

        [JsonPropertyName("description")]
        public string? Description { get; set; }

        [JsonPropertyName("packageId")]
        public string? PackageId { get; set; }

        [JsonPropertyName("severity")]
        public string? Severity { get; set; }

        [JsonPropertyName("type")]
        public string? Type { get; set; }

        [JsonPropertyName("published")]
        public DateTimeOffset Published { get; set; }
        [JsonPropertyName("score")]
        public double Score { get; set; }
        [JsonPropertyName("violatedPolicies")]
        public List<object>? ViolatedPolicies { get; set; } // Assuming array of unknown objects
        [JsonPropertyName("isExploitable")]
        public bool IsExploitable { get; set; }
        [JsonPropertyName("exploitabilityReason")]
        public string? ExploitabilityReason { get; set; }
        [JsonPropertyName("exploitabilityStatus")]
        public string? ExploitabilityStatus { get; set; }
        [JsonPropertyName("isKevDataExists")]
        public bool IsKevDataExists { get; set; }
        [JsonPropertyName("isExploitDbDataExists")]
        public bool IsExploitDbDataExists { get; set; }
        [JsonPropertyName("vulnerabilityFixResolutionText")]
        public string? VulnerabilityFixResolutionText { get; set; }
        [JsonPropertyName("relation")]
        public string? Relation { get; set; }
        [JsonPropertyName("epssData")]
        public EpssData? EpssData { get; set; }
        [JsonPropertyName("isEpssDataExists")]
        public bool IsEpssDataExists { get; set; }
        [JsonPropertyName("detectionDate")]
        public DateTimeOffset DetectionDate { get; set; }
        [JsonPropertyName("isVulnerabilityNew")]
        public bool IsVulnerabilityNew { get; set; }
        [JsonPropertyName("cweInfo")]
        public CweInfo? CweInfo { get; set; }
        [JsonPropertyName("packageInfo")]
        public PackageInfo? PackageInfo { get; set; }
        [JsonPropertyName("exploitablePath")]
        public ExploitablePath? ExploitablePath { get; set; }
        [JsonPropertyName("vulnerablePackagePath")]
        public VulnerablePackagePath? VulnerablePackagePath { get; set; }
        [JsonPropertyName("references")]
        public List<Reference>? References { get; set; }
        [JsonPropertyName("cvss2")]
        public Cvss2? Cvss2 { get; set; }
        [JsonPropertyName("cvss3")]
        public Cvss3? Cvss3 { get; set; }
        [JsonPropertyName("cvss4")]
        public Cvss4? Cvss4 { get; set; }
        [JsonPropertyName("pendingState")]
        public string? PendingState { get; set; }
        [JsonPropertyName("pendingChanges")]
        public bool PendingChanges { get; set; }

        [JsonPropertyName("packageState")]
        public PackageState? PackageState { get; set; }

        [JsonPropertyName("pendingScore")]
        public double PendingScore { get; set; }

        [JsonPropertyName("pendingSeverity")]
        public string? PendingSeverity { get; set; }

        [JsonPropertyName("isScoreOverridden")]
        public bool IsScoreOverridden { get; set; }

        public bool Match(ScaVulnerability findingToMatch)
        {
            if (findingToMatch == null)
                throw new ArgumentNullException(nameof(findingToMatch));

            return findingToMatch.Cve == Cve &&
                   findingToMatch.PackageInfo.Name == PackageInfo.Name &&
                   findingToMatch.PackageInfo.Version == PackageInfo.Version &&
                   findingToMatch.PackageInfo.PackageRepository == PackageInfo.PackageRepository;
        }
    }

}
